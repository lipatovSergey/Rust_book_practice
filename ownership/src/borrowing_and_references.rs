pub fn run_examples() {
    example_1();
    example_2();
    example_4();
    example_6();
    example_7();
}
// Из-за того что heap_allocated данные передаются а не копируются, то без дополнительного
// механизма каждый раз когда передаваемые значение были бы необходимы далее в коде, то пришлось бы
// каждый раз возвращать их из функции в которую они были переданны

fn example_1() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{s2}' is {len}.");

    fn calculate_length(s: String) -> (String, usize) {
        let length = s.len(); // len() returns the length of a String

        (s, length)
    }
}

// Для таких случаев Rust используются ссылки. Для обозначения ссылок используются амперсанд.
// Обрати внимание, что амперсанд добавляется и к типу дынных, указывая, что это ссылка на
// строку а не строка.
fn example_2() {
    let s1 = String::from("hello");

    let len = calculate_length_1(&s1);

    println!("The length of '{s1}' is {len}.");

    fn calculate_length_1(s: &String) -> usize {
        s.len()
    } // Here, s goes out of scope. But because s does not have ownership of what
    // it refers to, the String is not dropped.
}
// А что если попробовать изменить данные s внутри функции
//
// fn example_3() {
//     let s = String::from("hello");
//
//     change(&s);
//
//     fn change(some_string: &String) {
//         some_string.push_str(", world");
//     }
// }
//
// Это вызовет ошибку. Во первых s объявленно без mut. А значит через эту переменную данные вообще
// изменять нельзя. Во вторых сслыка переданная в фукцию тоже неизменяемая.
// Вот как правильно это оформить, чтобы всё работало
fn example_4() {
    let mut s = String::from("hello"); // muttable variable

    change(&mut s);

    fn change(some_string: &mut String) {
        // muttable too
        some_string.push_str(", world");
    }
}

// Ограничение о котором нужно всегда помнить. Не может быть более одной изменяемой ссылки на одно
// и тоже значение. Это помомгает избегать гонок данных. Пример неправильного кода
// fn example_5() {
//      let mut s = String::from("hello");
//
//      let r1 = &mut s;
//      let r2 = &mut s;
//
//      println!("{r1}, {r2}")
// }
// Гонки данных вызывают неопределённое поведение и их сложно диагностировать. Поэтому Rust их
// предотвращает на корню.
//
// При этом можно некто не запрещает использовать разные области видимости, для использования
// нескольких изменяемых сслылок, но не одновременно!
fn example_6() {
    let mut s = String::from("hello");
    {
        let r1 = &mut s;
    } // r1 goes out of scope here, so we can make a new reference with no problems.

    let r2 = &mut s;
}

// Неизменяемыех сслылок может быть сколько угодно. Компилятор точно уверен, тот кто может только
// читать данне не сможет их изменить и вызывать гогку данных.
fn example_7() {
    let mut s = String::from("hello");

    let r1 = &s;
    let r2 = &s;

    // Но запрещено добавлять изменяемую ссылку пока у нас есть неизменяемая ссылка на этоже
    // значение. Ниже в ptintln! обращается к переменным, которые содержат неизменяемую ссылку.
    // Если бы можно было добавить до вызова println! добавить изменяемую ссылку, было бы
    // затруднительно понять, что за значение должно быть иcпользованно.
    // let r3 = &mut s; Вызовет ошибку
    println!("{r1}, {r2}");

    // Пока ссылки используются, заимствование активно. После последнего использования -
    // заимствование закончено. А значит можно использовать изменяемую ссылку.
    let r3 = &mut s;
    // Но после
}

// dungling reference (Висячие ссылки)
// В языках исользующих указатели весьма просто случайно создать висячую ссылку. Ссылка есть, а
// данныx на которые она указывает уже не существует. В Rust компилятор гарантирует, что ссылки
// никогда не станут не недействительными.
fn example_8() {
    // fn dangle() -> &String {
    //     let s = String::from("hello");
    //     &s
    // }
    // s создаётся внутри dangle функции. А значит, когда функция будет завершена, s будет
    // освобождена, а мы пытаемся вернуть ссылку на неё. Это вызовет ошибку.

    // Решением будет вернуть непосредственно String а не сслыку.
    fn dangle() -> String {
        let s = String::from("hello");
        s
    }
    // Это работает без проблем. Владение перемещено и ничего не освобождено.
    let reference_to_nothing = dangle();
}
